use sqlx::mysql::MySqlArguments;
use sqlx::query::Query;
use sqlx::MySql;

/// SQL parameter values generated by dynamic query compilation.
#[derive(Debug, Clone)]
pub enum SqlParam {
    /// UTF-8 string parameter.
    String(String),
    /// Floating-point numeric parameter.
    Number(f64),
    /// Boolean parameter (`true`/`false`).
    Bool(bool),
}

/// WHERE clause SQL and bind values.
#[derive(Debug, Clone, Default)]
pub struct CompiledWhere {
    /// SQL expression without the leading `WHERE` keyword.
    pub clause: Option<String>,
    /// Bind parameters in placeholder order.
    pub params: Vec<SqlParam>,
}

/// Applies `SqlParam` values to a sqlx query in order.
pub fn bind_params<'q>(
    mut query: Query<'q, MySql, MySqlArguments>,
    params: &'q [SqlParam],
) -> Query<'q, MySql, MySqlArguments> {
    for parameter in params {
        query = match parameter {
            SqlParam::String(value) => query.bind(value),
            SqlParam::Number(value) => query.bind(value),
            SqlParam::Bool(value) => query.bind(value),
        };
    }
    query
}

/// Builds a comma-separated placeholder string like `"?, ?, ?"` for prepared SQL.
pub fn placeholders(count: usize) -> String {
    std::iter::repeat_n("?", count)
        .collect::<Vec<&str>>()
        .join(", ")
}
